// Package crypto provides quantum cryptography functionality including random number generation
// and secure key distribution using quantum principles.
package crypto

import (
	"errors"

	easyq "github.com/Henrikarba/easyq-go"
	"github.com/Henrikarba/easyq-go/bridge"
)

// RandomInt generates a true random integer between min (inclusive) and max (inclusive)
// using quantum measurement.
//
// Unlike classical pseudo-random number generators, this function produces numbers with
// true quantum randomness, making them suitable for cryptographic applications.
//
// Example:
//
//	// Generate a random number between 1 and 100
//	num, err := crypto.RandomInt(1, 100)
func RandomInt(min, max int) (int, error) {
	if min >= max {
		return 0, easyq.ErrInvalidRange
	}

	// Ensure we're initialized
	if err := easyq.EnsureInitialized(); err != nil {
		return 0, err
	}

	return bridge.GenerateRandomInt(min, max)
}

// RandomBytes generates a sequence of random bytes using quantum measurement.
// The generated bytes are suitable for cryptographic purposes.
//
// Example:
//
//	// Generate 32 random bytes (256 bits)
//	bytes, err := crypto.RandomBytes(32)
func RandomBytes(length int) ([]byte, error) {
	if length <= 0 {
		return nil, easyq.ErrInvalidLength
	}

	// Ensure we're initialized
	if err := easyq.EnsureInitialized(); err != nil {
		return nil, err
	}

	return bridge.GenerateRandomBytes(length)
}

// RandomPermutation generates a random permutation of integers from 0 to length-1
// using quantum randomness. This is useful for cryptographic shuffling.
//
// Example:
//
//	// Generate a random permutation of 0-9
//	perm, err := crypto.RandomPermutation(10)
func RandomPermutation(length int) ([]int, error) {
	if length <= 0 {
		return nil, easyq.ErrInvalidLength
	}

	// Ensure we're initialized
	if err := easyq.EnsureInitialized(); err != nil {
		return nil, err
	}

	// Generate permutation using Fisher-Yates shuffle with quantum randomness
	permutation := make([]int, length)
	for i := 0; i < length; i++ {
		permutation[i] = i
	}

	for i := length - 1; i > 0; i-- {
		// Use quantum randomness to select an index
		j, err := RandomInt(0, i)
		if err != nil {
			return nil, err
		}

		// Swap elements at i and j
		permutation[i], permutation[j] = permutation[j], permutation[i]
	}

	return permutation, nil
}

// FillRandomBuffer fills the provided buffer with random bytes
// using quantum random number generation.
func FillRandomBuffer(buffer []byte) error {
	if len(buffer) == 0 {
		return errors.New("buffer cannot be empty")
	}

	// Ensure we're initialized
	if err := easyq.EnsureInitialized(); err != nil {
		return err
	}

	// Generate random bytes
	randomBytes, err := bridge.GenerateRandomBytes(len(buffer))
	if err != nil {
		return err
	}

	// Copy to the provided buffer
	copy(buffer, randomBytes)
	return nil
}
