// Package crypto provides quantum cryptography functionality including random number generation
// and secure key distribution using quantum principles.
package crypto

import (
	"errors"

	"github.com/Henrikarba/easyq-go"
	"github.com/Henrikarba/easyq-go/internal/runtime"
)

// Random number generation functions

// RandomInt generates a true random integer between min (inclusive) and max (inclusive)
// using quantum measurement.
//
// Unlike classical pseudo-random number generators, this function produces numbers with
// true quantum randomness, making them suitable for cryptographic applications.
//
// Example:
//
//	import "github.com/Henrikarba/easyq-go/crypto"
//
//	// Generate a random number between 1 and 100
//	num, err := crypto.RandomInt(1, 100)
func RandomInt(min, max int) (int, error) {
	if min >= max {
		return 0, errors.New("minimum value must be less than maximum value")
	}

	// Ensure we're initialized
	if err := easyq.EnsureInitialized(); err != nil {
		return 0, err
	}

	return runtime.QuantumRNG(min, max)
}

// RandomBytes generates a sequence of random bytes using quantum measurement.
// The generated bytes are suitable for cryptographic purposes.
//
// Example:
//
//	import "github.com/yourusername/easyq-go/crypto"
//
//	// Generate 32 random bytes (256 bits)
//	bytes, err := crypto.RandomBytes(32)
func RandomBytes(length int) ([]byte, error) {
	if length <= 0 {
		return nil, errors.New("length must be greater than zero")
	}

	// Ensure we're initialized
	if err := easyq.EnsureInitialized(); err != nil {
		return nil, err
	}

	return runtime.QuantumRandomBytes(length)
}

// RandomPermutation generates a random permutation of integers from 0 to length-1
// using quantum randomness. This is useful for cryptographic shuffling.
//
// Example:
//
//	import "github.com/yourusername/easyq-go/crypto"
//
//	// Generate a random permutation of 0-9
//	perm, err := crypto.RandomPermutation(10)
func RandomPermutation(length int) ([]int, error) {
	if length <= 0 {
		return nil, errors.New("length must be greater than zero")
	}

	// Ensure we're initialized
	if err := easyq.EnsureInitialized(); err != nil {
		return nil, err
	}

	// Generate permutation using Fisher-Yates shuffle with quantum randomness
	permutation := make([]int, length)
	for i := 0; i < length; i++ {
		permutation[i] = i
	}

	for i := length - 1; i > 0; i-- {
		// Use quantum randomness to select an index
		j, err := runtime.QuantumRNG(0, i)
		if err != nil {
			return nil, err
		}

		// Swap elements at i and j
		permutation[i], permutation[j] = permutation[j], permutation[i]
	}

	return permutation, nil
}
